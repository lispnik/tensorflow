
;;;;    function.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:tensorflow.protobuf)
    (make-package '#:tensorflow.protobuf :use nil)))
(in-package #:tensorflow.protobuf)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass function-def-library (pb:protocol-buffer)
  (
  (function
   :accessor function
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::function-def
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::function-def))
  (gradient
   :accessor gradient
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::gradient-def
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::gradient-def))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'function-def-library)

(cl:export 'function)

(cl:unless (cl:fboundp 'clear-function)
  (cl:defgeneric clear-function (proto)))
(cl:defmethod clear-function ((self function-def-library))
  (cl:setf (cl:slot-value self 'function)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::function-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-function)

(cl:export 'gradient)

(cl:unless (cl:fboundp 'clear-gradient)
  (cl:defgeneric clear-gradient (proto)))
(cl:defmethod clear-gradient ((self function-def-library))
  (cl:setf (cl:slot-value self 'gradient)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::gradient-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-gradient)


(cl:defmethod cl:print-object ((self function-def-library) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_function: ~s" (function self))
      (cl:format stream " ~_gradient: ~s" (gradient self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self function-def-library))
  (cl:setf (cl:slot-value self 'function)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::function-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'gradient)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::gradient-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self function-def-library))
  cl:t)

(cl:defmethod pb:octet-size ((self function-def-library))
  (cl:let ((size 0))
    ;; repeated .tensorflow.protobuf.FunctionDef function = 1[json_name = "function"];
    (cl:let* ((v (cl:slot-value self 'function))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .tensorflow.protobuf.GradientDef gradient = 2[json_name = "gradient"];
    (cl:let* ((v (cl:slot-value self 'gradient))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self function-def-library) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated .tensorflow.protobuf.FunctionDef function = 1[json_name = "function"];
  (cl:let* ((v (cl:slot-value self 'function))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .tensorflow.protobuf.GradientDef gradient = 2[json_name = "gradient"];
  (cl:let* ((v (cl:slot-value self 'gradient))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self function-def-library) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated .tensorflow.protobuf.FunctionDef function = 1[json_name = "function"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::function-def)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'function)))))
        ;; repeated .tensorflow.protobuf.GradientDef gradient = 2[json_name = "gradient"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::gradient-def)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'gradient)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self function-def-library) (from function-def-library))
  (cl:let* ((v (cl:slot-value self 'function))
            (vf (cl:slot-value from 'function))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'gradient))
            (vf (cl:slot-value from 'gradient))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)


(cl:defclass function-def-attr-entry (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (value
   :writer (cl:setf value)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::attr-value))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'function-def-attr-entry)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self function-def-attr-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self function-def-attr-entry))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self function-def-attr-entry))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'value)

(cl:unless (cl:fboundp 'value)
  (cl:defgeneric value (proto)))
(cl:defmethod value ((self function-def-attr-entry))
  (cl:let ((result (cl:slot-value self 'value)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::attr-value))
      (cl:setf (cl:slot-value self 'value) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf value) :after (x (self function-def-attr-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self function-def-attr-entry))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self function-def-attr-entry))
  (cl:setf (cl:slot-value self 'value) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)



(cl:defclass function-def-ret-entry (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (value
   :accessor value
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'function-def-ret-entry)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self function-def-ret-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self function-def-ret-entry))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self function-def-ret-entry))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'value)


(cl:defmethod (cl:setf value) :after (x (self function-def-ret-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self function-def-ret-entry))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self function-def-ret-entry))
  (cl:setf (cl:slot-value self 'value) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)



(cl:defclass function-def (pb:protocol-buffer)
  (
  (signature
   :writer (cl:setf signature)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::op-def))
  (attr
   :accessor attr
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::function-def-attr-entry
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::function-def-attr-entry))
  (node-def
   :accessor node-def
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::node-def
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::node-def))
  (ret
   :accessor ret
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::function-def-ret-entry
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::function-def-ret-entry))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 4))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'function-def)

(cl:export 'signature)

(cl:unless (cl:fboundp 'signature)
  (cl:defgeneric signature (proto)))
(cl:defmethod signature ((self function-def))
  (cl:let ((result (cl:slot-value self 'signature)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::op-def))
      (cl:setf (cl:slot-value self 'signature) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf signature) :after (x (self function-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-signature)
  (cl:defgeneric has-signature (proto)))
(cl:defmethod has-signature ((self function-def))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-signature)

(cl:unless (cl:fboundp 'clear-signature)
  (cl:defgeneric clear-signature (proto)))
(cl:defmethod clear-signature ((self function-def))
  (cl:setf (cl:slot-value self 'signature) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-signature)

(cl:export 'attr)

(cl:unless (cl:fboundp 'clear-attr)
  (cl:defgeneric clear-attr (proto)))
(cl:defmethod clear-attr ((self function-def))
  (cl:setf (cl:slot-value self 'attr)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::function-def-attr-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-attr)

(cl:export 'node-def)

(cl:unless (cl:fboundp 'clear-node-def)
  (cl:defgeneric clear-node-def (proto)))
(cl:defmethod clear-node-def ((self function-def))
  (cl:setf (cl:slot-value self 'node-def)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::node-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-node-def)

(cl:export 'ret)

(cl:unless (cl:fboundp 'clear-ret)
  (cl:defgeneric clear-ret (proto)))
(cl:defmethod clear-ret ((self function-def))
  (cl:setf (cl:slot-value self 'ret)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::function-def-ret-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-ret)


(cl:defmethod cl:print-object ((self function-def-attr-entry) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self function-def-attr-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self function-def-attr-entry))
  cl:t)

(cl:defmethod pb:octet-size ((self function-def-attr-entry))
  (cl:let ((size 0))
    ;; string key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; .tensorflow.protobuf.AttrValue value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'value))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self function-def-attr-entry) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; .tensorflow.protobuf.AttrValue value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'value) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self function-def-attr-entry) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string key = 1[json_name = "key"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.AttrValue value = 2[json_name = "value"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'value)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
                (cl:setf (cl:slot-value self 'value) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self function-def-attr-entry) (from function-def-attr-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'value)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
        (cl:setf (cl:slot-value self 'value) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'value))))
)



(cl:defmethod cl:print-object ((self function-def-ret-entry) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self function-def-ret-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self function-def-ret-entry))
  cl:t)

(cl:defmethod pb:octet-size ((self function-def-ret-entry))
  (cl:let ((size 0))
    ;; string key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; string value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'value))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self function-def-ret-entry) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; string value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self function-def-ret-entry) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string key = 1[json_name = "key"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string value = 2[json_name = "value"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'value) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self function-def-ret-entry) (from function-def-ret-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (cl:slot-value from 'value))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self function-def) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_signature: ~s" (signature self)))
      (cl:format stream " ~_attr: ~s" (attr self))
      (cl:format stream " ~_node-def: ~s" (node-def self))
      (cl:format stream " ~_ret: ~s" (ret self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self function-def))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'signature) cl:nil))
  (cl:setf (cl:slot-value self 'attr)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::function-def-attr-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'node-def)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::node-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'ret)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::function-def-ret-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self function-def))
  cl:t)

(cl:defmethod pb:octet-size ((self function-def))
  (cl:let ((size 0))
    ;; .tensorflow.protobuf.OpDef signature = 1[json_name = "signature"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'signature))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; map<string, .tensorflow.protobuf.AttrValue> attr = 5[json_name = "attr"];
    (cl:let* ((v (cl:slot-value self 'attr))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .tensorflow.protobuf.NodeDef node_def = 3[json_name = "nodeDef"];
    (cl:let* ((v (cl:slot-value self 'node-def))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; map<string, string> ret = 4[json_name = "ret"];
    (cl:let* ((v (cl:slot-value self 'ret))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self function-def) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .tensorflow.protobuf.OpDef signature = 1[json_name = "signature"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'signature) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'signature) buffer index limit)))
  ;; repeated .tensorflow.protobuf.NodeDef node_def = 3[json_name = "nodeDef"];
  (cl:let* ((v (cl:slot-value self 'node-def))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; map<string, string> ret = 4[json_name = "ret"];
  (cl:let* ((v (cl:slot-value self 'ret))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; map<string, .tensorflow.protobuf.AttrValue> attr = 5[json_name = "attr"];
  (cl:let* ((v (cl:slot-value self 'attr))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self function-def) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .tensorflow.protobuf.OpDef signature = 1[json_name = "signature"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'signature)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::op-def))
                (cl:setf (cl:slot-value self 'signature) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .tensorflow.protobuf.NodeDef node_def = 3[json_name = "nodeDef"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::node-def)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'node-def)))))
        ;; map<string, string> ret = 4[json_name = "ret"];
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::function-def-ret-entry)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'ret)))))
        ;; map<string, .tensorflow.protobuf.AttrValue> attr = 5[json_name = "attr"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::function-def-attr-entry)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'attr)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self function-def) (from function-def))
  (cl:let* ((v (cl:slot-value self 'attr))
            (vf (cl:slot-value from 'attr))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'node-def))
            (vf (cl:slot-value from 'node-def))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'ret))
            (vf (cl:slot-value from 'ret))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'signature)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::op-def))
        (cl:setf (cl:slot-value self 'signature) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'signature))))
)


(cl:defclass gradient-def (pb:protocol-buffer)
  (
  (function-name
   :accessor function-name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (gradient-func
   :accessor gradient-func
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'gradient-def)

(cl:export 'function-name)


(cl:defmethod (cl:setf function-name) :after (x (self gradient-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-function-name)
  (cl:defgeneric has-function-name (proto)))
(cl:defmethod has-function-name ((self gradient-def))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-function-name)

(cl:unless (cl:fboundp 'clear-function-name)
  (cl:defgeneric clear-function-name (proto)))
(cl:defmethod clear-function-name ((self gradient-def))
  (cl:setf (cl:slot-value self 'function-name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-function-name)

(cl:export 'gradient-func)


(cl:defmethod (cl:setf gradient-func) :after (x (self gradient-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-gradient-func)
  (cl:defgeneric has-gradient-func (proto)))
(cl:defmethod has-gradient-func ((self gradient-def))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-gradient-func)

(cl:unless (cl:fboundp 'clear-gradient-func)
  (cl:defgeneric clear-gradient-func (proto)))
(cl:defmethod clear-gradient-func ((self gradient-def))
  (cl:setf (cl:slot-value self 'gradient-func) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-gradient-func)


(cl:defmethod cl:print-object ((self gradient-def) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_function-name: ~s" (function-name self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_gradient-func: ~s" (gradient-func self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self gradient-def))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'function-name) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'gradient-func) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self gradient-def))
  cl:t)

(cl:defmethod pb:octet-size ((self gradient-def))
  (cl:let ((size 0))
    ;; string function_name = 1[json_name = "functionName"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'function-name))))
        (cl:+ s (varint:length32 s)))))
    ;; string gradient_func = 2[json_name = "gradientFunc"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'gradient-func))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self gradient-def) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string function_name = 1[json_name = "functionName"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'function-name) 'pb::%octets%))))
  ;; string gradient_func = 2[json_name = "gradientFunc"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'gradient-func) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self gradient-def) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string function_name = 1[json_name = "functionName"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'function-name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string gradient_func = 2[json_name = "gradientFunc"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'gradient-func) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self gradient-def) (from gradient-def))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'function-name) (cl:slot-value from 'function-name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'gradient-func) (cl:slot-value from 'gradient-func))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


