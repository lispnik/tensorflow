
;;;;    op_def.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:tensorflow.protobuf)
    (make-package '#:tensorflow.protobuf :use nil)))
(in-package #:tensorflow.protobuf)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass op-def-arg-def (pb:protocol-buffer)
  (
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (type
   :accessor type
   :initform tensorflow.protobuf::+data-type-dt-invalid+
   :type tensorflow.protobuf::data-type)
  (type-attr
   :accessor type-attr
   :initform (pb:string-field "")
   :type pb::%sf%)
  (number-attr
   :accessor number-attr
   :initform (pb:string-field "")
   :type pb::%sf%)
  (type-list-attr
   :accessor type-list-attr
   :initform (pb:string-field "")
   :type pb::%sf%)
  (is-ref
   :accessor is-ref
   :initform cl:nil
   :type cl:boolean)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 7))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'op-def-arg-def)

(cl:export 'name)


(cl:defmethod (cl:setf name) :after (x (self op-def-arg-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self op-def-arg-def))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-name)

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self op-def-arg-def))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-name)

(cl:export 'description)


(cl:defmethod (cl:setf description) :after (x (self op-def-arg-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self op-def-arg-def))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description)

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self op-def-arg-def))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self op-def-arg-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self op-def-arg-def))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self op-def-arg-def))
  (cl:setf (cl:slot-value self 'type) tensorflow.protobuf::+data-type-dt-invalid+)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'type-attr)


(cl:defmethod (cl:setf type-attr) :after (x (self op-def-arg-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type-attr)
  (cl:defgeneric has-type-attr (proto)))
(cl:defmethod has-type-attr ((self op-def-arg-def))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type-attr)

(cl:unless (cl:fboundp 'clear-type-attr)
  (cl:defgeneric clear-type-attr (proto)))
(cl:defmethod clear-type-attr ((self op-def-arg-def))
  (cl:setf (cl:slot-value self 'type-attr) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type-attr)

(cl:export 'number-attr)


(cl:defmethod (cl:setf number-attr) :after (x (self op-def-arg-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-number-attr)
  (cl:defgeneric has-number-attr (proto)))
(cl:defmethod has-number-attr ((self op-def-arg-def))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-number-attr)

(cl:unless (cl:fboundp 'clear-number-attr)
  (cl:defgeneric clear-number-attr (proto)))
(cl:defmethod clear-number-attr ((self op-def-arg-def))
  (cl:setf (cl:slot-value self 'number-attr) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-number-attr)

(cl:export 'type-list-attr)


(cl:defmethod (cl:setf type-list-attr) :after (x (self op-def-arg-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type-list-attr)
  (cl:defgeneric has-type-list-attr (proto)))
(cl:defmethod has-type-list-attr ((self op-def-arg-def))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type-list-attr)

(cl:unless (cl:fboundp 'clear-type-list-attr)
  (cl:defgeneric clear-type-list-attr (proto)))
(cl:defmethod clear-type-list-attr ((self op-def-arg-def))
  (cl:setf (cl:slot-value self 'type-list-attr) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type-list-attr)

(cl:export 'is-ref)


(cl:defmethod (cl:setf is-ref) :after (x (self op-def-arg-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-is-ref)
  (cl:defgeneric has-is-ref (proto)))
(cl:defmethod has-is-ref ((self op-def-arg-def))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-is-ref)

(cl:unless (cl:fboundp 'clear-is-ref)
  (cl:defgeneric clear-is-ref (proto)))
(cl:defmethod clear-is-ref ((self op-def-arg-def))
  (cl:setf (cl:slot-value self 'is-ref) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-is-ref)



(cl:defclass op-def-attr-def (pb:protocol-buffer)
  (
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (type
   :accessor type
   :initform (pb:string-field "")
   :type pb::%sf%)
  (default-value
   :writer (cl:setf default-value)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::attr-value))
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (has-minimum
   :accessor has-minimum
   :initform cl:nil
   :type cl:boolean)
  (minimum
   :accessor minimum
   :initform 0
   :type (cl:signed-byte 64))
  (allowed-values
   :writer (cl:setf allowed-values)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::attr-value))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 7))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'op-def-attr-def)

(cl:export 'name)


(cl:defmethod (cl:setf name) :after (x (self op-def-attr-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self op-def-attr-def))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-name)

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self op-def-attr-def))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-name)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self op-def-attr-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self op-def-attr-def))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self op-def-attr-def))
  (cl:setf (cl:slot-value self 'type) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'default-value)

(cl:unless (cl:fboundp 'default-value)
  (cl:defgeneric default-value (proto)))
(cl:defmethod default-value ((self op-def-attr-def))
  (cl:let ((result (cl:slot-value self 'default-value)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::attr-value))
      (cl:setf (cl:slot-value self 'default-value) result))
      (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf default-value) :after (x (self op-def-attr-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-default-value)
  (cl:defgeneric has-default-value (proto)))
(cl:defmethod has-default-value ((self op-def-attr-def))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-default-value)

(cl:unless (cl:fboundp 'clear-default-value)
  (cl:defgeneric clear-default-value (proto)))
(cl:defmethod clear-default-value ((self op-def-attr-def))
  (cl:setf (cl:slot-value self 'default-value) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-default-value)

(cl:export 'description)


(cl:defmethod (cl:setf description) :after (x (self op-def-attr-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self op-def-attr-def))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description)

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self op-def-attr-def))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description)

(cl:export 'has-minimum)


(cl:defmethod (cl:setf has-minimum) :after (x (self op-def-attr-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-has-minimum)
  (cl:defgeneric has-has-minimum (proto)))
(cl:defmethod has-has-minimum ((self op-def-attr-def))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-has-minimum)

(cl:unless (cl:fboundp 'clear-has-minimum)
  (cl:defgeneric clear-has-minimum (proto)))
(cl:defmethod clear-has-minimum ((self op-def-attr-def))
  (cl:setf (cl:slot-value self 'has-minimum) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-has-minimum)

(cl:export 'minimum)


(cl:defmethod (cl:setf minimum) :after (x (self op-def-attr-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-minimum)
  (cl:defgeneric has-minimum (proto)))
(cl:defmethod has-minimum ((self op-def-attr-def))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-minimum)

(cl:unless (cl:fboundp 'clear-minimum)
  (cl:defgeneric clear-minimum (proto)))
(cl:defmethod clear-minimum ((self op-def-attr-def))
  (cl:setf (cl:slot-value self 'minimum) 0)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-minimum)

(cl:export 'allowed-values)

(cl:unless (cl:fboundp 'allowed-values)
  (cl:defgeneric allowed-values (proto)))
(cl:defmethod allowed-values ((self op-def-attr-def))
  (cl:let ((result (cl:slot-value self 'allowed-values)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::attr-value))
      (cl:setf (cl:slot-value self 'allowed-values) result))
      (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf allowed-values) :after (x (self op-def-attr-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-allowed-values)
  (cl:defgeneric has-allowed-values (proto)))
(cl:defmethod has-allowed-values ((self op-def-attr-def))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-allowed-values)

(cl:unless (cl:fboundp 'clear-allowed-values)
  (cl:defgeneric clear-allowed-values (proto)))
(cl:defmethod clear-allowed-values ((self op-def-attr-def))
  (cl:setf (cl:slot-value self 'allowed-values) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-allowed-values)



(cl:defclass op-def (pb:protocol-buffer)
  (
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (input-arg
   :accessor input-arg
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::op-def-arg-def
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::op-def-arg-def))
  (output-arg
   :accessor output-arg
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::op-def-arg-def
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::op-def-arg-def))
  (attr
   :accessor attr
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::op-def-attr-def
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::op-def-attr-def))
  (deprecation
   :writer (cl:setf deprecation)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::op-deprecation))
  (summary
   :accessor summary
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (is-commutative
   :accessor is-commutative
   :initform cl:nil
   :type cl:boolean)
  (is-aggregate
   :accessor is-aggregate
   :initform cl:nil
   :type cl:boolean)
  (is-stateful
   :accessor is-stateful
   :initform cl:nil
   :type cl:boolean)
  (allows-uninitialized-input
   :accessor allows-uninitialized-input
   :initform cl:nil
   :type cl:boolean)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 11))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'op-def)

(cl:export 'name)


(cl:defmethod (cl:setf name) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self op-def))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-name)

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self op-def))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-name)

(cl:export 'input-arg)

(cl:unless (cl:fboundp 'clear-input-arg)
  (cl:defgeneric clear-input-arg (proto)))
(cl:defmethod clear-input-arg ((self op-def))
  (cl:setf (cl:slot-value self 'input-arg)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def-arg-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-input-arg)

(cl:export 'output-arg)

(cl:unless (cl:fboundp 'clear-output-arg)
  (cl:defgeneric clear-output-arg (proto)))
(cl:defmethod clear-output-arg ((self op-def))
  (cl:setf (cl:slot-value self 'output-arg)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def-arg-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-output-arg)

(cl:export 'attr)

(cl:unless (cl:fboundp 'clear-attr)
  (cl:defgeneric clear-attr (proto)))
(cl:defmethod clear-attr ((self op-def))
  (cl:setf (cl:slot-value self 'attr)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def-attr-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-attr)

(cl:export 'deprecation)

(cl:unless (cl:fboundp 'deprecation)
  (cl:defgeneric deprecation (proto)))
(cl:defmethod deprecation ((self op-def))
  (cl:let ((result (cl:slot-value self 'deprecation)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::op-deprecation))
      (cl:setf (cl:slot-value self 'deprecation) result))
      (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf deprecation) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-deprecation)
  (cl:defgeneric has-deprecation (proto)))
(cl:defmethod has-deprecation ((self op-def))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-deprecation)

(cl:unless (cl:fboundp 'clear-deprecation)
  (cl:defgeneric clear-deprecation (proto)))
(cl:defmethod clear-deprecation ((self op-def))
  (cl:setf (cl:slot-value self 'deprecation) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-deprecation)

(cl:export 'summary)


(cl:defmethod (cl:setf summary) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-summary)
  (cl:defgeneric has-summary (proto)))
(cl:defmethod has-summary ((self op-def))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-summary)

(cl:unless (cl:fboundp 'clear-summary)
  (cl:defgeneric clear-summary (proto)))
(cl:defmethod clear-summary ((self op-def))
  (cl:setf (cl:slot-value self 'summary) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-summary)

(cl:export 'description)


(cl:defmethod (cl:setf description) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self op-def))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description)

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self op-def))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description)

(cl:export 'is-commutative)


(cl:defmethod (cl:setf is-commutative) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-is-commutative)
  (cl:defgeneric has-is-commutative (proto)))
(cl:defmethod has-is-commutative ((self op-def))
  (cl:logbitp 7 (cl:slot-value self '%has-bits%)))
(cl:export 'has-is-commutative)

(cl:unless (cl:fboundp 'clear-is-commutative)
  (cl:defgeneric clear-is-commutative (proto)))
(cl:defmethod clear-is-commutative ((self op-def))
  (cl:setf (cl:slot-value self 'is-commutative) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-is-commutative)

(cl:export 'is-aggregate)


(cl:defmethod (cl:setf is-aggregate) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-is-aggregate)
  (cl:defgeneric has-is-aggregate (proto)))
(cl:defmethod has-is-aggregate ((self op-def))
  (cl:logbitp 8 (cl:slot-value self '%has-bits%)))
(cl:export 'has-is-aggregate)

(cl:unless (cl:fboundp 'clear-is-aggregate)
  (cl:defgeneric clear-is-aggregate (proto)))
(cl:defmethod clear-is-aggregate ((self op-def))
  (cl:setf (cl:slot-value self 'is-aggregate) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-is-aggregate)

(cl:export 'is-stateful)


(cl:defmethod (cl:setf is-stateful) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-is-stateful)
  (cl:defgeneric has-is-stateful (proto)))
(cl:defmethod has-is-stateful ((self op-def))
  (cl:logbitp 9 (cl:slot-value self '%has-bits%)))
(cl:export 'has-is-stateful)

(cl:unless (cl:fboundp 'clear-is-stateful)
  (cl:defgeneric clear-is-stateful (proto)))
(cl:defmethod clear-is-stateful ((self op-def))
  (cl:setf (cl:slot-value self 'is-stateful) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-is-stateful)

(cl:export 'allows-uninitialized-input)


(cl:defmethod (cl:setf allows-uninitialized-input) :after (x (self op-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-allows-uninitialized-input)
  (cl:defgeneric has-allows-uninitialized-input (proto)))
(cl:defmethod has-allows-uninitialized-input ((self op-def))
  (cl:logbitp 10 (cl:slot-value self '%has-bits%)))
(cl:export 'has-allows-uninitialized-input)

(cl:unless (cl:fboundp 'clear-allows-uninitialized-input)
  (cl:defgeneric clear-allows-uninitialized-input (proto)))
(cl:defmethod clear-allows-uninitialized-input ((self op-def))
  (cl:setf (cl:slot-value self 'allows-uninitialized-input) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-allows-uninitialized-input)


(cl:defmethod cl:print-object ((self op-def-arg-def) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type-attr: ~s" (type-attr self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_number-attr: ~s" (number-attr self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type-list-attr: ~s" (type-list-attr self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_is-ref: ~s" (is-ref self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self op-def-arg-def))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'type) tensorflow.protobuf::+data-type-dt-invalid+)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'type-attr) (pb:string-field "")))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'number-attr) (pb:string-field "")))
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'type-list-attr) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'is-ref) cl:nil)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self op-def-arg-def))
  cl:t)

(cl:defmethod pb:octet-size ((self op-def-arg-def))
  (cl:let ((size 0))
    ;; string name = 1[json_name = "name"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; string description = 2[json_name = "description"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; .tensorflow.protobuf.DataType type = 3[json_name = "type"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; string type_attr = 4[json_name = "typeAttr"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'type-attr))))
        (cl:+ s (varint:length32 s)))))
    ;; string number_attr = 5[json_name = "numberAttr"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'number-attr))))
        (cl:+ s (varint:length32 s)))))
    ;; string type_list_attr = 6[json_name = "typeListAttr"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'type-list-attr))))
        (cl:+ s (varint:length32 s)))))
    ;; bool is_ref = 16[json_name = "isRef"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self op-def-arg-def) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string name = 1[json_name = "name"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; string description = 2[json_name = "description"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; .tensorflow.protobuf.DataType type = 3[json_name = "type"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; string type_attr = 4[json_name = "typeAttr"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'type-attr) 'pb::%octets%))))
  ;; string number_attr = 5[json_name = "numberAttr"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'number-attr) 'pb::%octets%))))
  ;; string type_list_attr = 6[json_name = "typeListAttr"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'type-list-attr) 'pb::%octets%))))
  ;; bool is_ref = 16[json_name = "isRef"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 128))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'is-ref))))
  index)

(cl:defmethod pb:merge-from-array ((self op-def-arg-def) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string name = 1[json_name = "name"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string description = 2[json_name = "description"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'description) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.DataType type = 3[json_name = "type"];
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string type_attr = 4[json_name = "typeAttr"];
        ((34)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'type-attr) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string number_attr = 5[json_name = "numberAttr"];
        ((42)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'number-attr) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string type_list_attr = 6[json_name = "typeListAttr"];
        ((50)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'type-list-attr) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bool is_ref = 16[json_name = "isRef"];
        ((128)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'is-ref) value)
            (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self op-def-arg-def) (from op-def-arg-def))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type-attr) (cl:slot-value from 'type-attr))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'number-attr) (cl:slot-value from 'number-attr))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type-list-attr) (cl:slot-value from 'type-list-attr))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'is-ref) (cl:slot-value from 'is-ref))
    (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self op-def-attr-def) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_default-value: ~s" (default-value self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_has-minimum: ~s" (has-minimum self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_minimum: ~s" (minimum self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_allowed-values: ~s" (allowed-values self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self op-def-attr-def))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'default-value) cl:nil))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'has-minimum) cl:nil)
  (cl:setf (cl:slot-value self 'minimum) 0)
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'allowed-values) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self op-def-attr-def))
  cl:t)

(cl:defmethod pb:octet-size ((self op-def-attr-def))
  (cl:let ((size 0))
    ;; string name = 1[json_name = "name"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; string type = 2[json_name = "type"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'type))))
        (cl:+ s (varint:length32 s)))))
    ;; .tensorflow.protobuf.AttrValue default_value = 3[json_name = "defaultValue"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'default-value))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; string description = 4[json_name = "description"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; bool has_minimum = 5[json_name = "hasMinimum"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; int64 minimum = 6[json_name = "minimum"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'minimum))))))
    ;; .tensorflow.protobuf.AttrValue allowed_values = 7[json_name = "allowedValues"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'allowed-values))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self op-def-attr-def) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string name = 1[json_name = "name"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; string type = 2[json_name = "type"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'type) 'pb::%octets%))))
  ;; .tensorflow.protobuf.AttrValue default_value = 3[json_name = "defaultValue"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'default-value) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'default-value) buffer index limit)))
  ;; string description = 4[json_name = "description"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; bool has_minimum = 5[json_name = "hasMinimum"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'has-minimum))))
  ;; int64 minimum = 6[json_name = "minimum"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'minimum)))))
  ;; .tensorflow.protobuf.AttrValue allowed_values = 7[json_name = "allowedValues"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'allowed-values) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'allowed-values) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self op-def-attr-def) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string name = 1[json_name = "name"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string type = 2[json_name = "type"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'type) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.AttrValue default_value = 3[json_name = "defaultValue"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'default-value)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
                (cl:setf (cl:slot-value self 'default-value) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; string description = 4[json_name = "description"];
        ((34)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'description) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bool has_minimum = 5[json_name = "hasMinimum"];
        ((40)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'has-minimum) value)
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; int64 minimum = 6[json_name = "minimum"];
        ((48)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'minimum) value)
            (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.AttrValue allowed_values = 7[json_name = "allowedValues"];
        ((58)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'allowed-values)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
                (cl:setf (cl:slot-value self 'allowed-values) message)
                (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self op-def-attr-def) (from op-def-attr-def))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'default-value)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
        (cl:setf (cl:slot-value self 'default-value) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'default-value))))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'has-minimum) (cl:slot-value from 'has-minimum))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'minimum) (cl:slot-value from 'minimum))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'allowed-values)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
        (cl:setf (cl:slot-value self 'allowed-values) message)
        (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'allowed-values))))
)



(cl:defmethod cl:print-object ((self op-def) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:format stream " ~_input-arg: ~s" (input-arg self))
      (cl:format stream " ~_output-arg: ~s" (output-arg self))
      (cl:format stream " ~_attr: ~s" (attr self))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_deprecation: ~s" (deprecation self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_summary: ~s" (summary self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_is-commutative: ~s" (is-commutative self)))
      (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_is-aggregate: ~s" (is-aggregate self)))
      (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_is-stateful: ~s" (is-stateful self)))
      (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_allows-uninitialized-input: ~s" (allows-uninitialized-input self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self op-def))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'deprecation) cl:nil))
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'summary) (pb:string-field "")))
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'is-commutative) cl:nil)
  (cl:setf (cl:slot-value self 'is-aggregate) cl:nil)
  (cl:setf (cl:slot-value self 'is-stateful) cl:nil)
  (cl:setf (cl:slot-value self 'allows-uninitialized-input) cl:nil)
  (cl:setf (cl:slot-value self 'input-arg)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def-arg-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'output-arg)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def-arg-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'attr)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def-attr-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self op-def))
  cl:t)

(cl:defmethod pb:octet-size ((self op-def))
  (cl:let ((size 0))
    ;; string name = 1[json_name = "name"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; .tensorflow.protobuf.OpDeprecation deprecation = 8[json_name = "deprecation"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'deprecation))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; string summary = 5[json_name = "summary"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'summary))))
        (cl:+ s (varint:length32 s)))))
    ;; string description = 6[json_name = "description"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; bool is_commutative = 18[json_name = "isCommutative"];
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    ;; bool is_aggregate = 16[json_name = "isAggregate"];
    (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    ;; bool is_stateful = 17[json_name = "isStateful"];
    (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    ;; bool allows_uninitialized_input = 19[json_name = "allowsUninitializedInput"];
    (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 2 1)))
    ;; repeated .tensorflow.protobuf.OpDef.ArgDef input_arg = 2[json_name = "inputArg"];
    (cl:let* ((v (cl:slot-value self 'input-arg))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .tensorflow.protobuf.OpDef.ArgDef output_arg = 3[json_name = "outputArg"];
    (cl:let* ((v (cl:slot-value self 'output-arg))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .tensorflow.protobuf.OpDef.AttrDef attr = 4[json_name = "attr"];
    (cl:let* ((v (cl:slot-value self 'attr))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self op-def) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string name = 1[json_name = "name"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; repeated .tensorflow.protobuf.OpDef.ArgDef input_arg = 2[json_name = "inputArg"];
  (cl:let* ((v (cl:slot-value self 'input-arg))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .tensorflow.protobuf.OpDef.ArgDef output_arg = 3[json_name = "outputArg"];
  (cl:let* ((v (cl:slot-value self 'output-arg))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .tensorflow.protobuf.OpDef.AttrDef attr = 4[json_name = "attr"];
  (cl:let* ((v (cl:slot-value self 'attr))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; string summary = 5[json_name = "summary"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'summary) 'pb::%octets%))))
  ;; string description = 6[json_name = "description"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; .tensorflow.protobuf.OpDeprecation deprecation = 8[json_name = "deprecation"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'deprecation) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'deprecation) buffer index limit)))
  ;; bool is_aggregate = 16[json_name = "isAggregate"];
  (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 128))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'is-aggregate))))
  ;; bool is_stateful = 17[json_name = "isStateful"];
  (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 136))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'is-stateful))))
  ;; bool is_commutative = 18[json_name = "isCommutative"];
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 144))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'is-commutative))))
  ;; bool allows_uninitialized_input = 19[json_name = "allowsUninitializedInput"];
  (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 152))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'allows-uninitialized-input))))
  index)

(cl:defmethod pb:merge-from-array ((self op-def) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string name = 1[json_name = "name"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated .tensorflow.protobuf.OpDef.ArgDef input_arg = 2[json_name = "inputArg"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::op-def-arg-def)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'input-arg)))))
        ;; repeated .tensorflow.protobuf.OpDef.ArgDef output_arg = 3[json_name = "outputArg"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::op-def-arg-def)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'output-arg)))))
        ;; repeated .tensorflow.protobuf.OpDef.AttrDef attr = 4[json_name = "attr"];
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::op-def-attr-def)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'attr)))))
        ;; string summary = 5[json_name = "summary"];
        ((42)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'summary) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string description = 6[json_name = "description"];
        ((50)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'description) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.OpDeprecation deprecation = 8[json_name = "deprecation"];
        ((66)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'deprecation)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::op-deprecation))
                (cl:setf (cl:slot-value self 'deprecation) message)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; bool is_aggregate = 16[json_name = "isAggregate"];
        ((128)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'is-aggregate) value)
            (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bool is_stateful = 17[json_name = "isStateful"];
        ((136)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'is-stateful) value)
            (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bool is_commutative = 18[json_name = "isCommutative"];
        ((144)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'is-commutative) value)
            (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bool allows_uninitialized_input = 19[json_name = "allowsUninitializedInput"];
        ((152)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'allows-uninitialized-input) value)
            (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self op-def) (from op-def))
  (cl:let* ((v (cl:slot-value self 'input-arg))
            (vf (cl:slot-value from 'input-arg))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'output-arg))
            (vf (cl:slot-value from 'output-arg))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'attr))
            (vf (cl:slot-value from 'attr))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'deprecation)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::op-deprecation))
        (cl:setf (cl:slot-value self 'deprecation) message)
        (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'deprecation))))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'summary) (cl:slot-value from 'summary))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 7 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'is-commutative) (cl:slot-value from 'is-commutative))
    (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 8 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'is-aggregate) (cl:slot-value from 'is-aggregate))
    (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 9 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'is-stateful) (cl:slot-value from 'is-stateful))
    (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 10 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'allows-uninitialized-input) (cl:slot-value from 'allows-uninitialized-input))
    (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass op-deprecation (pb:protocol-buffer)
  (
  (version
   :accessor version
   :initform 0
   :type (cl:signed-byte 32))
  (explanation
   :accessor explanation
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'op-deprecation)

(cl:export 'version)


(cl:defmethod (cl:setf version) :after (x (self op-deprecation))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-version)
  (cl:defgeneric has-version (proto)))
(cl:defmethod has-version ((self op-deprecation))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-version)

(cl:unless (cl:fboundp 'clear-version)
  (cl:defgeneric clear-version (proto)))
(cl:defmethod clear-version ((self op-deprecation))
  (cl:setf (cl:slot-value self 'version) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-version)

(cl:export 'explanation)


(cl:defmethod (cl:setf explanation) :after (x (self op-deprecation))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-explanation)
  (cl:defgeneric has-explanation (proto)))
(cl:defmethod has-explanation ((self op-deprecation))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-explanation)

(cl:unless (cl:fboundp 'clear-explanation)
  (cl:defgeneric clear-explanation (proto)))
(cl:defmethod clear-explanation ((self op-deprecation))
  (cl:setf (cl:slot-value self 'explanation) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-explanation)


(cl:defmethod cl:print-object ((self op-deprecation) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_version: ~s" (version self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_explanation: ~s" (explanation self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self op-deprecation))
  (cl:setf (cl:slot-value self 'version) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'explanation) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self op-deprecation))
  cl:t)

(cl:defmethod pb:octet-size ((self op-deprecation))
  (cl:let ((size 0))
    ;; int32 version = 1[json_name = "version"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'version))))))
    ;; string explanation = 2[json_name = "explanation"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'explanation))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self op-deprecation) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int32 version = 1[json_name = "version"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'version)))))
  ;; string explanation = 2[json_name = "explanation"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'explanation) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self op-deprecation) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; int32 version = 1[json_name = "version"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'version) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string explanation = 2[json_name = "explanation"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'explanation) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self op-deprecation) (from op-deprecation))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'version) (cl:slot-value from 'version))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'explanation) (cl:slot-value from 'explanation))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass op-list (pb:protocol-buffer)
  (
  (op
   :accessor op
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::op-def
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::op-def))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'op-list)

(cl:export 'op)

(cl:unless (cl:fboundp 'clear-op)
  (cl:defgeneric clear-op (proto)))
(cl:defmethod clear-op ((self op-list))
  (cl:setf (cl:slot-value self 'op)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-op)


(cl:defmethod cl:print-object ((self op-list) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_op: ~s" (op self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self op-list))
  (cl:setf (cl:slot-value self 'op)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::op-def
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self op-list))
  cl:t)

(cl:defmethod pb:octet-size ((self op-list))
  (cl:let ((size 0))
    ;; repeated .tensorflow.protobuf.OpDef op = 1[json_name = "op"];
    (cl:let* ((v (cl:slot-value self 'op))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self op-list) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated .tensorflow.protobuf.OpDef op = 1[json_name = "op"];
  (cl:let* ((v (cl:slot-value self 'op))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self op-list) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated .tensorflow.protobuf.OpDef op = 1[json_name = "op"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::op-def)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'op)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self op-list) (from op-list))
  (cl:let* ((v (cl:slot-value self 'op))
            (vf (cl:slot-value from 'op))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)


