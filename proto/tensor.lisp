
;;;;    tensor.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:tensorflow.protobuf)
    (make-package '#:tensorflow.protobuf :use nil)))
(in-package #:tensorflow.protobuf)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass tensor-proto (pb:protocol-buffer)
  (
  (dtype
   :accessor dtype
   :initform tensorflow.protobuf::+data-type-dt-invalid+
   :type tensorflow.protobuf::data-type)
  (tensor-shape
   :writer (cl:setf tensor-shape)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::tensor-shape-proto))
  (version-number
   :accessor version-number
   :initform 0
   :type (cl:signed-byte 32))
  (tensor-content
   :accessor tensor-content
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (half-val
   :accessor half-val
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 32)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 32)))
  (float-val
   :accessor float-val
   :initform (cl:make-array
              0
              :element-type 'cl:single-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:single-float))
  (double-val
   :accessor double-val
   :initform (cl:make-array
              0
              :element-type 'cl:double-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:double-float))
  (int-val
   :accessor int-val
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 32)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 32)))
  (string-val
   :accessor string-val
   :initform (cl:make-array
              0
              :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:simple-array (cl:unsigned-byte 8) (cl:*))))
  (scomplex-val
   :accessor scomplex-val
   :initform (cl:make-array
              0
              :element-type 'cl:single-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:single-float))
  (int64-val
   :accessor int64-val
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 64)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 64)))
  (bool-val
   :accessor bool-val
   :initform (cl:make-array
              0
              :element-type 'cl:boolean
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:boolean))
  (dcomplex-val
   :accessor dcomplex-val
   :initform (cl:make-array
              0
              :element-type 'cl:double-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:double-float))
  (resource-handle-val
   :accessor resource-handle-val
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::resource-handle-proto
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::resource-handle-proto))
  (variant-val
   :accessor variant-val
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::variant-tensor-data-proto
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::variant-tensor-data-proto))
  (uint32-val
   :accessor uint32-val
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 32)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:unsigned-byte 32)))
  (uint64-val
   :accessor uint64-val
   :initform (cl:make-array
              0
              :element-type '(cl:unsigned-byte 64)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:unsigned-byte 64)))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 17))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'tensor-proto)

(cl:export 'dtype)


(cl:defmethod (cl:setf dtype) :after (x (self tensor-proto))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-dtype)
  (cl:defgeneric has-dtype (proto)))
(cl:defmethod has-dtype ((self tensor-proto))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-dtype)

(cl:unless (cl:fboundp 'clear-dtype)
  (cl:defgeneric clear-dtype (proto)))
(cl:defmethod clear-dtype ((self tensor-proto))
  (cl:setf (cl:slot-value self 'dtype) tensorflow.protobuf::+data-type-dt-invalid+)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-dtype)

(cl:export 'tensor-shape)

(cl:unless (cl:fboundp 'tensor-shape)
  (cl:defgeneric tensor-shape (proto)))
(cl:defmethod tensor-shape ((self tensor-proto))
  (cl:let ((result (cl:slot-value self 'tensor-shape)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::tensor-shape-proto))
      (cl:setf (cl:slot-value self 'tensor-shape) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf tensor-shape) :after (x (self tensor-proto))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-tensor-shape)
  (cl:defgeneric has-tensor-shape (proto)))
(cl:defmethod has-tensor-shape ((self tensor-proto))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-tensor-shape)

(cl:unless (cl:fboundp 'clear-tensor-shape)
  (cl:defgeneric clear-tensor-shape (proto)))
(cl:defmethod clear-tensor-shape ((self tensor-proto))
  (cl:setf (cl:slot-value self 'tensor-shape) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-tensor-shape)

(cl:export 'version-number)


(cl:defmethod (cl:setf version-number) :after (x (self tensor-proto))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-version-number)
  (cl:defgeneric has-version-number (proto)))
(cl:defmethod has-version-number ((self tensor-proto))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-version-number)

(cl:unless (cl:fboundp 'clear-version-number)
  (cl:defgeneric clear-version-number (proto)))
(cl:defmethod clear-version-number ((self tensor-proto))
  (cl:setf (cl:slot-value self 'version-number) 0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-version-number)

(cl:export 'tensor-content)


(cl:defmethod (cl:setf tensor-content) :after (x (self tensor-proto))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-tensor-content)
  (cl:defgeneric has-tensor-content (proto)))
(cl:defmethod has-tensor-content ((self tensor-proto))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-tensor-content)

(cl:unless (cl:fboundp 'clear-tensor-content)
  (cl:defgeneric clear-tensor-content (proto)))
(cl:defmethod clear-tensor-content ((self tensor-proto))
  (cl:setf (cl:slot-value self 'tensor-content) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-tensor-content)

(cl:export 'half-val)

(cl:unless (cl:fboundp 'clear-half-val)
  (cl:defgeneric clear-half-val (proto)))
(cl:defmethod clear-half-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'half-val)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-half-val)

(cl:export 'float-val)

(cl:unless (cl:fboundp 'clear-float-val)
  (cl:defgeneric clear-float-val (proto)))
(cl:defmethod clear-float-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'float-val)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-float-val)

(cl:export 'double-val)

(cl:unless (cl:fboundp 'clear-double-val)
  (cl:defgeneric clear-double-val (proto)))
(cl:defmethod clear-double-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'double-val)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-double-val)

(cl:export 'int-val)

(cl:unless (cl:fboundp 'clear-int-val)
  (cl:defgeneric clear-int-val (proto)))
(cl:defmethod clear-int-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'int-val)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-int-val)

(cl:export 'string-val)

(cl:unless (cl:fboundp 'clear-string-val)
  (cl:defgeneric clear-string-val (proto)))
(cl:defmethod clear-string-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'string-val)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-string-val)

(cl:export 'scomplex-val)

(cl:unless (cl:fboundp 'clear-scomplex-val)
  (cl:defgeneric clear-scomplex-val (proto)))
(cl:defmethod clear-scomplex-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'scomplex-val)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-scomplex-val)

(cl:export 'int64-val)

(cl:unless (cl:fboundp 'clear-int64-val)
  (cl:defgeneric clear-int64-val (proto)))
(cl:defmethod clear-int64-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'int64-val)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-int64-val)

(cl:export 'bool-val)

(cl:unless (cl:fboundp 'clear-bool-val)
  (cl:defgeneric clear-bool-val (proto)))
(cl:defmethod clear-bool-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'bool-val)
           (cl:make-array 0 :element-type 'cl:boolean
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-bool-val)

(cl:export 'dcomplex-val)

(cl:unless (cl:fboundp 'clear-dcomplex-val)
  (cl:defgeneric clear-dcomplex-val (proto)))
(cl:defmethod clear-dcomplex-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'dcomplex-val)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-dcomplex-val)

(cl:export 'resource-handle-val)

(cl:unless (cl:fboundp 'clear-resource-handle-val)
  (cl:defgeneric clear-resource-handle-val (proto)))
(cl:defmethod clear-resource-handle-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'resource-handle-val)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::resource-handle-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-resource-handle-val)

(cl:export 'variant-val)

(cl:unless (cl:fboundp 'clear-variant-val)
  (cl:defgeneric clear-variant-val (proto)))
(cl:defmethod clear-variant-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'variant-val)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::variant-tensor-data-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-variant-val)

(cl:export 'uint32-val)

(cl:unless (cl:fboundp 'clear-uint32-val)
  (cl:defgeneric clear-uint32-val (proto)))
(cl:defmethod clear-uint32-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'uint32-val)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-uint32-val)

(cl:export 'uint64-val)

(cl:unless (cl:fboundp 'clear-uint64-val)
  (cl:defgeneric clear-uint64-val (proto)))
(cl:defmethod clear-uint64-val ((self tensor-proto))
  (cl:setf (cl:slot-value self 'uint64-val)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-uint64-val)


(cl:defmethod cl:print-object ((self tensor-proto) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_dtype: ~s" (dtype self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_tensor-shape: ~s" (tensor-shape self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_version-number: ~s" (version-number self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_tensor-content: ~s" (tensor-content self)))
      (cl:format stream " ~_half-val: ~s" (half-val self))
      (cl:format stream " ~_float-val: ~s" (float-val self))
      (cl:format stream " ~_double-val: ~s" (double-val self))
      (cl:format stream " ~_int-val: ~s" (int-val self))
      (cl:format stream " ~_string-val: ~s" (string-val self))
      (cl:format stream " ~_scomplex-val: ~s" (scomplex-val self))
      (cl:format stream " ~_int64-val: ~s" (int64-val self))
      (cl:format stream " ~_bool-val: ~s" (bool-val self))
      (cl:format stream " ~_dcomplex-val: ~s" (dcomplex-val self))
      (cl:format stream " ~_resource-handle-val: ~s" (resource-handle-val self))
      (cl:format stream " ~_variant-val: ~s" (variant-val self))
      (cl:format stream " ~_uint32-val: ~s" (uint32-val self))
      (cl:format stream " ~_uint64-val: ~s" (uint64-val self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self tensor-proto))
  (cl:setf (cl:slot-value self 'dtype) tensorflow.protobuf::+data-type-dt-invalid+)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'tensor-shape) cl:nil))
  (cl:setf (cl:slot-value self 'version-number) 0)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'tensor-content) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:setf (cl:slot-value self 'half-val)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'float-val)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'double-val)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'int-val)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'string-val)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'scomplex-val)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'int64-val)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'bool-val)
           (cl:make-array 0 :element-type 'cl:boolean
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'dcomplex-val)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'resource-handle-val)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::resource-handle-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'variant-val)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::variant-tensor-data-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'uint32-val)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'uint64-val)
           (cl:make-array 0 :element-type '(cl:unsigned-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self tensor-proto))
  cl:t)

(cl:defmethod pb:octet-size ((self tensor-proto))
  (cl:let ((size 0))
    ;; .tensorflow.protobuf.DataType dtype = 1[json_name = "dtype"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'dtype)))))
    ;; .tensorflow.protobuf.TensorShapeProto tensor_shape = 2[json_name = "tensorShape"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'tensor-shape))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; int32 version_number = 3[json_name = "versionNumber"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'version-number))))))
    ;; bytes tensor_content = 4[json_name = "tensorContent"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'tensor-content))))
        (cl:+ s (varint:length32 s)))))
    ;; repeated int32 half_val = 13[json_name = "halfVal", packed = true];
    (cl:let* ((x (cl:slot-value self 'half-val))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (cl:ldb (cl:byte 64 0) (cl:aref (cl:slot-value self 'half-val) i))))))
    ;; repeated float float_val = 5[json_name = "floatVal", packed = true];
    (cl:incf size (cl:* (cl:+ 1 4)
                     (cl:length (cl:slot-value self 'float-val))))
    ;; repeated double double_val = 6[json_name = "doubleVal", packed = true];
    (cl:incf size (cl:* (cl:+ 1 8)
                     (cl:length (cl:slot-value self 'double-val))))
    ;; repeated int32 int_val = 7[json_name = "intVal", packed = true];
    (cl:let* ((x (cl:slot-value self 'int-val))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (cl:ldb (cl:byte 64 0) (cl:aref (cl:slot-value self 'int-val) i))))))
    ;; repeated bytes string_val = 8[json_name = "stringVal"];
    (cl:let* ((x (cl:slot-value self 'string-val))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size (cl:let ((s (cl:length (cl:aref x i))))
  (cl:+ s (varint:length32 s))))))
    ;; repeated float scomplex_val = 9[json_name = "scomplexVal", packed = true];
    (cl:incf size (cl:* (cl:+ 1 4)
                     (cl:length (cl:slot-value self 'scomplex-val))))
    ;; repeated int64 int64_val = 10[json_name = "int64Val", packed = true];
    (cl:let* ((x (cl:slot-value self 'int64-val))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (cl:ldb (cl:byte 64 0) (cl:aref (cl:slot-value self 'int64-val) i))))))
    ;; repeated bool bool_val = 11[json_name = "boolVal", packed = true];
    (cl:incf size (cl:* (cl:+ 1 1)
                     (cl:length (cl:slot-value self 'bool-val))))
    ;; repeated double dcomplex_val = 12[json_name = "dcomplexVal", packed = true];
    (cl:incf size (cl:* (cl:+ 1 8)
                     (cl:length (cl:slot-value self 'dcomplex-val))))
    ;; repeated .tensorflow.protobuf.ResourceHandleProto resource_handle_val = 14[json_name = "resourceHandleVal"];
    (cl:let* ((v (cl:slot-value self 'resource-handle-val))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .tensorflow.protobuf.VariantTensorDataProto variant_val = 15[json_name = "variantVal"];
    (cl:let* ((v (cl:slot-value self 'variant-val))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated uint32 uint32_val = 16[json_name = "uint32Val", packed = true];
    (cl:let* ((x (cl:slot-value self 'uint32-val))
              (length (cl:length x)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length32 (cl:aref (cl:slot-value self 'uint32-val) i)))))
    ;; repeated uint64 uint64_val = 17[json_name = "uint64Val", packed = true];
    (cl:let* ((x (cl:slot-value self 'uint64-val))
              (length (cl:length x)))
      (cl:incf size (cl:* 2 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (cl:aref (cl:slot-value self 'uint64-val) i)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self tensor-proto) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .tensorflow.protobuf.DataType dtype = 1[json_name = "dtype"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'dtype)))))
  ;; .tensorflow.protobuf.TensorShapeProto tensor_shape = 2[json_name = "tensorShape"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'tensor-shape) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'tensor-shape) buffer index limit)))
  ;; int32 version_number = 3[json_name = "versionNumber"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'version-number)))))
  ;; bytes tensor_content = 4[json_name = "tensorContent"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'tensor-content))))
  ;; repeated float float_val = 5[json_name = "floatVal", packed = true];
  (cl:let* ((v (cl:slot-value self 'float-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
      (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated double double_val = 6[json_name = "doubleVal", packed = true];
  (cl:let* ((v (cl:slot-value self 'double-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
      (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated int32 int_val = 7[json_name = "intVal", packed = true];
  (cl:let* ((v (cl:slot-value self 'int-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:aref v i))))))
  ;; repeated bytes string_val = 8[json_name = "stringVal"];
  (cl:let* ((v (cl:slot-value self 'string-val))
            (length (cl:length v)))
    (cl:dotimes (i length)
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
      (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:aref v i)))))
  ;; repeated float scomplex_val = 9[json_name = "scomplexVal", packed = true];
  (cl:let* ((v (cl:slot-value self 'scomplex-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
      (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated int64 int64_val = 10[json_name = "int64Val", packed = true];
  (cl:let* ((v (cl:slot-value self 'int64-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 82))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:aref v i))))))
  ;; repeated bool bool_val = 11[json_name = "boolVal", packed = true];
  (cl:let* ((v (cl:slot-value self 'bool-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 90))
      (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:aref v i)))))
  ;; repeated double dcomplex_val = 12[json_name = "dcomplexVal", packed = true];
  (cl:let* ((v (cl:slot-value self 'dcomplex-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 98))
      (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated int32 half_val = 13[json_name = "halfVal", packed = true];
  (cl:let* ((v (cl:slot-value self 'half-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 106))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:aref v i))))))
  ;; repeated .tensorflow.protobuf.ResourceHandleProto resource_handle_val = 14[json_name = "resourceHandleVal"];
  (cl:let* ((v (cl:slot-value self 'resource-handle-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 114))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .tensorflow.protobuf.VariantTensorDataProto variant_val = 15[json_name = "variantVal"];
  (cl:let* ((v (cl:slot-value self 'variant-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 122))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated uint32 uint32_val = 16[json_name = "uint32Val", packed = true];
  (cl:let* ((v (cl:slot-value self 'uint32-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 130))
      (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:aref v i)))))
  ;; repeated uint64 uint64_val = 17[json_name = "uint64Val", packed = true];
  (cl:let* ((v (cl:slot-value self 'uint64-val))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 138))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:aref v i)))))
  index)

(cl:defmethod pb:merge-from-array ((self tensor-proto) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .tensorflow.protobuf.DataType dtype = 1[json_name = "dtype"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'dtype) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.TensorShapeProto tensor_shape = 2[json_name = "tensorShape"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'tensor-shape)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::tensor-shape-proto))
                (cl:setf (cl:slot-value self 'tensor-shape) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; int32 version_number = 3[json_name = "versionNumber"];
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'version-number) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bytes tensor_content = 4[json_name = "tensorContent"];
        ((34)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'tensor-content) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated float float_val = 5[json_name = "floatVal", packed = true];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (wire-format:read-single-float-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'float-val))
                    (cl:setf index new-index))))))
        ;; repeated double double_val = 6[json_name = "doubleVal", packed = true];
        ((50)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (wire-format:read-double-float-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'double-val))
                    (cl:setf index new-index))))))
        ;; repeated int32 int_val = 7[json_name = "intVal", packed = true];
        ((58)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (varint:parse-int32-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'int-val))
                    (cl:setf index new-index))))))
        ;; repeated bytes string_val = 8[json_name = "stringVal"];
        ((66)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:vector-push-extend value (cl:slot-value self 'string-val))
            (cl:setf index new-index)))
        ;; repeated float scomplex_val = 9[json_name = "scomplexVal", packed = true];
        ((74)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (wire-format:read-single-float-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'scomplex-val))
                    (cl:setf index new-index))))))
        ;; repeated int64 int64_val = 10[json_name = "int64Val", packed = true];
        ((82)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (varint:parse-int64-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'int64-val))
                    (cl:setf index new-index))))))
        ;; repeated bool bool_val = 11[json_name = "boolVal", packed = true];
        ((90)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (wire-format:read-boolean-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'bool-val))
                    (cl:setf index new-index))))))
        ;; repeated double dcomplex_val = 12[json_name = "dcomplexVal", packed = true];
        ((98)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (wire-format:read-double-float-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'dcomplex-val))
                    (cl:setf index new-index))))))
        ;; repeated int32 half_val = 13[json_name = "halfVal", packed = true];
        ((106)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (varint:parse-int32-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'half-val))
                    (cl:setf index new-index))))))
        ;; repeated .tensorflow.protobuf.ResourceHandleProto resource_handle_val = 14[json_name = "resourceHandleVal"];
        ((114)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::resource-handle-proto)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'resource-handle-val)))))
        ;; repeated .tensorflow.protobuf.VariantTensorDataProto variant_val = 15[json_name = "variantVal"];
        ((122)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::variant-tensor-data-proto)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'variant-val)))))
        ;; repeated uint32 uint32_val = 16[json_name = "uint32Val", packed = true];
        ((130)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (varint:parse-uint32-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'uint32-val))
                    (cl:setf index new-index))))))
        ;; repeated uint64 uint64_val = 17[json_name = "uint64Val", packed = true];
        ((138)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (varint:parse-uint64-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'uint64-val))
                    (cl:setf index new-index))))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self tensor-proto) (from tensor-proto))
  (cl:let* ((v (cl:slot-value self 'half-val))
            (vf (cl:slot-value from 'half-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'float-val))
            (vf (cl:slot-value from 'float-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'double-val))
            (vf (cl:slot-value from 'double-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'int-val))
            (vf (cl:slot-value from 'int-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let ((v (cl:slot-value self 'string-val))
           (vf (cl:slot-value from 'string-val)))
    (cl:dotimes (i (cl:length vf))
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'scomplex-val))
            (vf (cl:slot-value from 'scomplex-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'int64-val))
            (vf (cl:slot-value from 'int64-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'bool-val))
            (vf (cl:slot-value from 'bool-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'dcomplex-val))
            (vf (cl:slot-value from 'dcomplex-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'resource-handle-val))
            (vf (cl:slot-value from 'resource-handle-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'variant-val))
            (vf (cl:slot-value from 'variant-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'uint32-val))
            (vf (cl:slot-value from 'uint32-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'uint64-val))
            (vf (cl:slot-value from 'uint64-val))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'dtype) (cl:slot-value from 'dtype))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'tensor-shape)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::tensor-shape-proto))
        (cl:setf (cl:slot-value self 'tensor-shape) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'tensor-shape))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'version-number) (cl:slot-value from 'version-number))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'tensor-content) (cl:slot-value from 'tensor-content))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass variant-tensor-data-proto (pb:protocol-buffer)
  (
  (type-name
   :accessor type-name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (metadata
   :accessor metadata
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (tensors
   :accessor tensors
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::tensor-proto
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::tensor-proto))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'variant-tensor-data-proto)

(cl:export 'type-name)


(cl:defmethod (cl:setf type-name) :after (x (self variant-tensor-data-proto))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type-name)
  (cl:defgeneric has-type-name (proto)))
(cl:defmethod has-type-name ((self variant-tensor-data-proto))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type-name)

(cl:unless (cl:fboundp 'clear-type-name)
  (cl:defgeneric clear-type-name (proto)))
(cl:defmethod clear-type-name ((self variant-tensor-data-proto))
  (cl:setf (cl:slot-value self 'type-name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type-name)

(cl:export 'metadata)


(cl:defmethod (cl:setf metadata) :after (x (self variant-tensor-data-proto))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-metadata)
  (cl:defgeneric has-metadata (proto)))
(cl:defmethod has-metadata ((self variant-tensor-data-proto))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-metadata)

(cl:unless (cl:fboundp 'clear-metadata)
  (cl:defgeneric clear-metadata (proto)))
(cl:defmethod clear-metadata ((self variant-tensor-data-proto))
  (cl:setf (cl:slot-value self 'metadata) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-metadata)

(cl:export 'tensors)

(cl:unless (cl:fboundp 'clear-tensors)
  (cl:defgeneric clear-tensors (proto)))
(cl:defmethod clear-tensors ((self variant-tensor-data-proto))
  (cl:setf (cl:slot-value self 'tensors)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::tensor-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-tensors)


(cl:defmethod cl:print-object ((self variant-tensor-data-proto) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type-name: ~s" (type-name self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_metadata: ~s" (metadata self)))
      (cl:format stream " ~_tensors: ~s" (tensors self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self variant-tensor-data-proto))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'type-name) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'metadata) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:setf (cl:slot-value self 'tensors)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::tensor-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self variant-tensor-data-proto))
  cl:t)

(cl:defmethod pb:octet-size ((self variant-tensor-data-proto))
  (cl:let ((size 0))
    ;; string type_name = 1[json_name = "typeName"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'type-name))))
        (cl:+ s (varint:length32 s)))))
    ;; bytes metadata = 2[json_name = "metadata"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 'metadata))))
        (cl:+ s (varint:length32 s)))))
    ;; repeated .tensorflow.protobuf.TensorProto tensors = 3[json_name = "tensors"];
    (cl:let* ((v (cl:slot-value self 'tensors))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self variant-tensor-data-proto) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string type_name = 1[json_name = "typeName"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'type-name) 'pb::%octets%))))
  ;; bytes metadata = 2[json_name = "metadata"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 'metadata))))
  ;; repeated .tensorflow.protobuf.TensorProto tensors = 3[json_name = "tensors"];
  (cl:let* ((v (cl:slot-value self 'tensors))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self variant-tensor-data-proto) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string type_name = 1[json_name = "typeName"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'type-name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bytes metadata = 2[json_name = "metadata"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'metadata) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated .tensorflow.protobuf.TensorProto tensors = 3[json_name = "tensors"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::tensor-proto)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'tensors)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self variant-tensor-data-proto) (from variant-tensor-data-proto))
  (cl:let* ((v (cl:slot-value self 'tensors))
            (vf (cl:slot-value from 'tensors))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type-name) (cl:slot-value from 'type-name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'metadata) (cl:slot-value from 'metadata))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


