
;;;;    attr_value.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:tensorflow.protobuf)
    (make-package '#:tensorflow.protobuf :use nil)))
(in-package #:tensorflow.protobuf)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass attr-value-list-value (pb:protocol-buffer)
  (
  (s
   :accessor s
   :initform (cl:make-array
              0
              :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:simple-array (cl:unsigned-byte 8) (cl:*))))
  (i
   :accessor i
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 64)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 64)))
  (f
   :accessor f
   :initform (cl:make-array
              0
              :element-type 'cl:single-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:single-float))
  (b
   :accessor b
   :initform (cl:make-array
              0
              :element-type 'cl:boolean
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:boolean))
  (type
   :accessor type
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::data-type
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::data-type))
  (shape
   :accessor shape
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::tensor-shape-proto
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::tensor-shape-proto))
  (tensor
   :accessor tensor
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::tensor-proto
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::tensor-proto))
  (func
   :accessor func
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::name-attr-list
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::name-attr-list))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 8))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'attr-value-list-value)

(cl:export 's)

(cl:unless (cl:fboundp 'clear-s)
  (cl:defgeneric clear-s (proto)))
(cl:defmethod clear-s ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 's)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-s)

(cl:export 'i)

(cl:unless (cl:fboundp 'clear-i)
  (cl:defgeneric clear-i (proto)))
(cl:defmethod clear-i ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 'i)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-i)

(cl:export 'f)

(cl:unless (cl:fboundp 'clear-f)
  (cl:defgeneric clear-f (proto)))
(cl:defmethod clear-f ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 'f)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-f)

(cl:export 'b)

(cl:unless (cl:fboundp 'clear-b)
  (cl:defgeneric clear-b (proto)))
(cl:defmethod clear-b ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 'b)
           (cl:make-array 0 :element-type 'cl:boolean
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-b)

(cl:export 'type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 'type)
           (cl:make-array
            0
            :element-type 'tensorflow.protobuf::data-type
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-type)

(cl:export 'shape)

(cl:unless (cl:fboundp 'clear-shape)
  (cl:defgeneric clear-shape (proto)))
(cl:defmethod clear-shape ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 'shape)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::tensor-shape-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-shape)

(cl:export 'tensor)

(cl:unless (cl:fboundp 'clear-tensor)
  (cl:defgeneric clear-tensor (proto)))
(cl:defmethod clear-tensor ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 'tensor)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::tensor-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-tensor)

(cl:export 'func)

(cl:unless (cl:fboundp 'clear-func)
  (cl:defgeneric clear-func (proto)))
(cl:defmethod clear-func ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 'func)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::name-attr-list
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-func)



(cl:defclass attr-value (pb:protocol-buffer)
  (
  (s
   :accessor s
   :initform (cl:make-array 0 :element-type '(cl:unsigned-byte 8))
   :type (cl:simple-array (cl:unsigned-byte 8) (cl:*)))
  (i
   :accessor i
   :initform 0
   :type (cl:signed-byte 64))
  (f
   :accessor f
   :initform 0f0
   :type cl:single-float)
  (b
   :accessor b
   :initform cl:nil
   :type cl:boolean)
  (type
   :accessor type
   :initform tensorflow.protobuf::+data-type-dt-invalid+
   :type tensorflow.protobuf::data-type)
  (shape
   :writer (cl:setf shape)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::tensor-shape-proto))
  (tensor
   :writer (cl:setf tensor)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::tensor-proto))
  (list
   :writer (cl:setf list)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::attr-value-list-value))
  (func
   :writer (cl:setf func)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::name-attr-list))
  (placeholder
   :accessor placeholder
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 10))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'attr-value)

(cl:export 's)


(cl:defmethod (cl:setf s) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-s)
  (cl:defgeneric has-s (proto)))
(cl:defmethod has-s ((self attr-value))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-s)

(cl:unless (cl:fboundp 'clear-s)
  (cl:defgeneric clear-s (proto)))
(cl:defmethod clear-s ((self attr-value))
  (cl:setf (cl:slot-value self 's) (cl:make-array 0 :element-type '(cl:unsigned-byte 8)))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-s)

(cl:export 'i)


(cl:defmethod (cl:setf i) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-i)
  (cl:defgeneric has-i (proto)))
(cl:defmethod has-i ((self attr-value))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-i)

(cl:unless (cl:fboundp 'clear-i)
  (cl:defgeneric clear-i (proto)))
(cl:defmethod clear-i ((self attr-value))
  (cl:setf (cl:slot-value self 'i) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-i)

(cl:export 'f)


(cl:defmethod (cl:setf f) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-f)
  (cl:defgeneric has-f (proto)))
(cl:defmethod has-f ((self attr-value))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-f)

(cl:unless (cl:fboundp 'clear-f)
  (cl:defgeneric clear-f (proto)))
(cl:defmethod clear-f ((self attr-value))
  (cl:setf (cl:slot-value self 'f) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-f)

(cl:export 'b)


(cl:defmethod (cl:setf b) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-b)
  (cl:defgeneric has-b (proto)))
(cl:defmethod has-b ((self attr-value))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-b)

(cl:unless (cl:fboundp 'clear-b)
  (cl:defgeneric clear-b (proto)))
(cl:defmethod clear-b ((self attr-value))
  (cl:setf (cl:slot-value self 'b) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-b)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self attr-value))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self attr-value))
  (cl:setf (cl:slot-value self 'type) tensorflow.protobuf::+data-type-dt-invalid+)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'shape)

(cl:unless (cl:fboundp 'shape)
  (cl:defgeneric shape (proto)))
(cl:defmethod shape ((self attr-value))
  (cl:let ((result (cl:slot-value self 'shape)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::tensor-shape-proto))
      (cl:setf (cl:slot-value self 'shape) result))
      (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf shape) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-shape)
  (cl:defgeneric has-shape (proto)))
(cl:defmethod has-shape ((self attr-value))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-shape)

(cl:unless (cl:fboundp 'clear-shape)
  (cl:defgeneric clear-shape (proto)))
(cl:defmethod clear-shape ((self attr-value))
  (cl:setf (cl:slot-value self 'shape) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-shape)

(cl:export 'tensor)

(cl:unless (cl:fboundp 'tensor)
  (cl:defgeneric tensor (proto)))
(cl:defmethod tensor ((self attr-value))
  (cl:let ((result (cl:slot-value self 'tensor)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::tensor-proto))
      (cl:setf (cl:slot-value self 'tensor) result))
      (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf tensor) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-tensor)
  (cl:defgeneric has-tensor (proto)))
(cl:defmethod has-tensor ((self attr-value))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-tensor)

(cl:unless (cl:fboundp 'clear-tensor)
  (cl:defgeneric clear-tensor (proto)))
(cl:defmethod clear-tensor ((self attr-value))
  (cl:setf (cl:slot-value self 'tensor) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-tensor)

(cl:export 'list)

(cl:unless (cl:fboundp 'list)
  (cl:defgeneric list (proto)))
(cl:defmethod list ((self attr-value))
  (cl:let ((result (cl:slot-value self 'list)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::attr-value-list-value))
      (cl:setf (cl:slot-value self 'list) result))
      (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf list) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-list)
  (cl:defgeneric has-list (proto)))
(cl:defmethod has-list ((self attr-value))
  (cl:logbitp 7 (cl:slot-value self '%has-bits%)))
(cl:export 'has-list)

(cl:unless (cl:fboundp 'clear-list)
  (cl:defgeneric clear-list (proto)))
(cl:defmethod clear-list ((self attr-value))
  (cl:setf (cl:slot-value self 'list) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-list)

(cl:export 'func)

(cl:unless (cl:fboundp 'func)
  (cl:defgeneric func (proto)))
(cl:defmethod func ((self attr-value))
  (cl:let ((result (cl:slot-value self 'func)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::name-attr-list))
      (cl:setf (cl:slot-value self 'func) result))
      (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf func) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-func)
  (cl:defgeneric has-func (proto)))
(cl:defmethod has-func ((self attr-value))
  (cl:logbitp 8 (cl:slot-value self '%has-bits%)))
(cl:export 'has-func)

(cl:unless (cl:fboundp 'clear-func)
  (cl:defgeneric clear-func (proto)))
(cl:defmethod clear-func ((self attr-value))
  (cl:setf (cl:slot-value self 'func) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-func)

(cl:export 'placeholder)


(cl:defmethod (cl:setf placeholder) :after (x (self attr-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-placeholder)
  (cl:defgeneric has-placeholder (proto)))
(cl:defmethod has-placeholder ((self attr-value))
  (cl:logbitp 9 (cl:slot-value self '%has-bits%)))
(cl:export 'has-placeholder)

(cl:unless (cl:fboundp 'clear-placeholder)
  (cl:defgeneric clear-placeholder (proto)))
(cl:defmethod clear-placeholder ((self attr-value))
  (cl:setf (cl:slot-value self 'placeholder) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-placeholder)


(cl:defmethod cl:print-object ((self attr-value-list-value) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_s: ~s" (s self))
      (cl:format stream " ~_i: ~s" (i self))
      (cl:format stream " ~_f: ~s" (f self))
      (cl:format stream " ~_b: ~s" (b self))
      (cl:format stream " ~_type: ~s" (type self))
      (cl:format stream " ~_shape: ~s" (shape self))
      (cl:format stream " ~_tensor: ~s" (tensor self))
      (cl:format stream " ~_func: ~s" (func self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self attr-value-list-value))
  (cl:setf (cl:slot-value self 's)
           (cl:make-array
            0
            :element-type '(cl:simple-array (cl:unsigned-byte 8) (cl:*))
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'i)
           (cl:make-array 0 :element-type '(cl:signed-byte 64)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'f)
           (cl:make-array 0 :element-type 'cl:single-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'b)
           (cl:make-array 0 :element-type 'cl:boolean
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'type)
           (cl:make-array
            0
            :element-type 'tensorflow.protobuf::data-type
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'shape)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::tensor-shape-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'tensor)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::tensor-proto
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'func)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::name-attr-list
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self attr-value-list-value))
  cl:t)

(cl:defmethod pb:octet-size ((self attr-value-list-value))
  (cl:let ((size 0))
    ;; repeated bytes s = 2[json_name = "s"];
    (cl:let* ((x (cl:slot-value self 's))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size (cl:let ((s (cl:length (cl:aref x i))))
  (cl:+ s (varint:length32 s))))))
    ;; repeated int64 i = 3[json_name = "i", packed = true];
    (cl:let* ((x (cl:slot-value self 'i))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (cl:ldb (cl:byte 64 0) (cl:aref (cl:slot-value self 'i) i))))))
    ;; repeated float f = 4[json_name = "f", packed = true];
    (cl:incf size (cl:* (cl:+ 1 4)
                     (cl:length (cl:slot-value self 'f))))
    ;; repeated bool b = 5[json_name = "b", packed = true];
    (cl:incf size (cl:* (cl:+ 1 1)
                     (cl:length (cl:slot-value self 'b))))
    ;; repeated .tensorflow.protobuf.DataType type = 6[json_name = "type", packed = true];
    (cl:let* ((x (cl:slot-value self 'type))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size (varint:length32 (cl:ldb (cl:byte 32 0) (cl:aref x i))))))
    ;; repeated .tensorflow.protobuf.TensorShapeProto shape = 7[json_name = "shape"];
    (cl:let* ((v (cl:slot-value self 'shape))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .tensorflow.protobuf.TensorProto tensor = 8[json_name = "tensor"];
    (cl:let* ((v (cl:slot-value self 'tensor))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .tensorflow.protobuf.NameAttrList func = 9[json_name = "func"];
    (cl:let* ((v (cl:slot-value self 'func))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self attr-value-list-value) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated bytes s = 2[json_name = "s"];
  (cl:let* ((v (cl:slot-value self 's))
            (length (cl:length v)))
    (cl:dotimes (i length)
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
      (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:aref v i)))))
  ;; repeated int64 i = 3[json_name = "i", packed = true];
  (cl:let* ((v (cl:slot-value self 'i))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:aref v i))))))
  ;; repeated float f = 4[json_name = "f", packed = true];
  (cl:let* ((v (cl:slot-value self 'f))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
      (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:aref v i)))))
  ;; repeated bool b = 5[json_name = "b", packed = true];
  (cl:let* ((v (cl:slot-value self 'b))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
      (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:aref v i)))))
  ;; repeated .tensorflow.protobuf.DataType type = 6[json_name = "type", packed = true];
  (cl:let* ((v (cl:slot-value self 'type))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit
                      (cl:ldb (cl:byte 64 0) (cl:aref v i))))))
  ;; repeated .tensorflow.protobuf.TensorShapeProto shape = 7[json_name = "shape"];
  (cl:let* ((v (cl:slot-value self 'shape))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .tensorflow.protobuf.TensorProto tensor = 8[json_name = "tensor"];
  (cl:let* ((v (cl:slot-value self 'tensor))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .tensorflow.protobuf.NameAttrList func = 9[json_name = "func"];
  (cl:let* ((v (cl:slot-value self 'func))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self attr-value-list-value) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated bytes s = 2[json_name = "s"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:vector-push-extend value (cl:slot-value self 's))
            (cl:setf index new-index)))
        ;; repeated int64 i = 3[json_name = "i", packed = true];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (varint:parse-int64-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'i))
                    (cl:setf index new-index))))))
        ;; repeated float f = 4[json_name = "f", packed = true];
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (wire-format:read-single-float-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'f))
                    (cl:setf index new-index))))))
        ;; repeated bool b = 5[json_name = "b", packed = true];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (wire-format:read-boolean-carefully buffer index limit)
                    (cl:vector-push-extend value (cl:slot-value self 'b))
                    (cl:setf index new-index))))))
        ;; repeated .tensorflow.protobuf.DataType type = 6[json_name = "type", packed = true];
        ((50)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint32-carefully buffer index limit)
            (cl:setf index new-index)
            (cl:let ((end (cl:+ index length)))
              (cl:loop while (cl:< index end) do
                (cl:multiple-value-bind (value new-index)
                    (varint:parse-int32-carefully buffer index limit)
                  ;; XXXXX: when valid, set field, else add to unknown fields
                  (cl:vector-push-extend value (cl:slot-value self 'type))
                  (cl:setf index new-index))))))
        ;; repeated .tensorflow.protobuf.TensorShapeProto shape = 7[json_name = "shape"];
        ((58)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::tensor-shape-proto)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'shape)))))
        ;; repeated .tensorflow.protobuf.TensorProto tensor = 8[json_name = "tensor"];
        ((66)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::tensor-proto)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'tensor)))))
        ;; repeated .tensorflow.protobuf.NameAttrList func = 9[json_name = "func"];
        ((74)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::name-attr-list)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'func)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self attr-value-list-value) (from attr-value-list-value))
  (cl:let ((v (cl:slot-value self 's))
           (vf (cl:slot-value from 's)))
    (cl:dotimes (i (cl:length vf))
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'i))
            (vf (cl:slot-value from 'i))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'f))
            (vf (cl:slot-value from 'f))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'b))
            (vf (cl:slot-value from 'b))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'type))
            (vf (cl:slot-value from 'type))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'shape))
            (vf (cl:slot-value from 'shape))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'tensor))
            (vf (cl:slot-value from 'tensor))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'func))
            (vf (cl:slot-value from 'func))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)



(cl:defmethod cl:print-object ((self attr-value) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_s: ~s" (s self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_i: ~s" (i self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_f: ~s" (f self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_b: ~s" (b self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_shape: ~s" (shape self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_tensor: ~s" (tensor self)))
      (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_list: ~s" (list self)))
      (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_func: ~s" (func self)))
      (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_placeholder: ~s" (placeholder self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self attr-value))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 's) (cl:make-array 0 :element-type '(cl:unsigned-byte 8))))
  (cl:setf (cl:slot-value self 'i) 0)
  (cl:setf (cl:slot-value self 'f) 0f0)
  (cl:setf (cl:slot-value self 'b) cl:nil)
  (cl:setf (cl:slot-value self 'type) tensorflow.protobuf::+data-type-dt-invalid+)
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'shape) cl:nil))
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'tensor) cl:nil))
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'list) cl:nil))
  (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'func) cl:nil))
  (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'placeholder) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self attr-value))
  cl:t)

(cl:defmethod pb:octet-size ((self attr-value))
  (cl:let ((size 0))
    ;; bytes s = 2[json_name = "s"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (cl:length (cl:slot-value self 's))))
        (cl:+ s (varint:length32 s)))))
    ;; int64 i = 3[json_name = "i"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'i))))))
    ;; float f = 4[json_name = "f"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; bool b = 5[json_name = "b"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; .tensorflow.protobuf.DataType type = 6[json_name = "type"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; .tensorflow.protobuf.TensorShapeProto shape = 7[json_name = "shape"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'shape))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .tensorflow.protobuf.TensorProto tensor = 8[json_name = "tensor"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'tensor))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .tensorflow.protobuf.AttrValue.ListValue list = 1[json_name = "list"];
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'list))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .tensorflow.protobuf.NameAttrList func = 10[json_name = "func"];
    (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'func))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; string placeholder = 9[json_name = "placeholder"];
    (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'placeholder))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self attr-value) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .tensorflow.protobuf.AttrValue.ListValue list = 1[json_name = "list"];
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'list) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'list) buffer index limit)))
  ;; bytes s = 2[json_name = "s"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value self 's))))
  ;; int64 i = 3[json_name = "i"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 24))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'i)))))
  ;; float f = 4[json_name = "f"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 37))
    (cl:setf index (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'f))))
  ;; bool b = 5[json_name = "b"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'b))))
  ;; .tensorflow.protobuf.DataType type = 6[json_name = "type"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; .tensorflow.protobuf.TensorShapeProto shape = 7[json_name = "shape"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'shape) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'shape) buffer index limit)))
  ;; .tensorflow.protobuf.TensorProto tensor = 8[json_name = "tensor"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'tensor) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'tensor) buffer index limit)))
  ;; string placeholder = 9[json_name = "placeholder"];
  (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'placeholder) 'pb::%octets%))))
  ;; .tensorflow.protobuf.NameAttrList func = 10[json_name = "func"];
  (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 82))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'func) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'func) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self attr-value) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .tensorflow.protobuf.AttrValue.ListValue list = 1[json_name = "list"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'list)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value-list-value))
                (cl:setf (cl:slot-value self 'list) message)
                (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; bytes s = 2[json_name = "s"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 's) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; int64 i = 3[json_name = "i"];
        ((24)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'i) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; float f = 4[json_name = "f"];
        ((37)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-single-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'f) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bool b = 5[json_name = "b"];
        ((40)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'b) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.DataType type = 6[json_name = "type"];
        ((48)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.TensorShapeProto shape = 7[json_name = "shape"];
        ((58)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'shape)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::tensor-shape-proto))
                (cl:setf (cl:slot-value self 'shape) message)
                (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .tensorflow.protobuf.TensorProto tensor = 8[json_name = "tensor"];
        ((66)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'tensor)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::tensor-proto))
                (cl:setf (cl:slot-value self 'tensor) message)
                (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; string placeholder = 9[json_name = "placeholder"];
        ((74)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'placeholder) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.NameAttrList func = 10[json_name = "func"];
        ((82)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'func)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::name-attr-list))
                (cl:setf (cl:slot-value self 'func) message)
                (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self attr-value) (from attr-value))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 's) (cl:slot-value from 's))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'i) (cl:slot-value from 'i))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'f) (cl:slot-value from 'f))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'b) (cl:slot-value from 'b))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'shape)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::tensor-shape-proto))
        (cl:setf (cl:slot-value self 'shape) message)
        (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'shape))))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'tensor)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::tensor-proto))
        (cl:setf (cl:slot-value self 'tensor) message)
        (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'tensor))))
  (cl:when (cl:logbitp 7 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'list)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value-list-value))
        (cl:setf (cl:slot-value self 'list) message)
        (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'list))))
  (cl:when (cl:logbitp 8 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'func)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::name-attr-list))
        (cl:setf (cl:slot-value self 'func) message)
        (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'func))))
  (cl:when (cl:logbitp 9 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'placeholder) (cl:slot-value from 'placeholder))
    (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass name-attr-list-attr-entry (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (value
   :writer (cl:setf value)
   :initform cl:nil
   :type (cl:or cl:null tensorflow.protobuf::attr-value))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'name-attr-list-attr-entry)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self name-attr-list-attr-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self name-attr-list-attr-entry))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self name-attr-list-attr-entry))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'value)

(cl:unless (cl:fboundp 'value)
  (cl:defgeneric value (proto)))
(cl:defmethod value ((self name-attr-list-attr-entry))
  (cl:let ((result (cl:slot-value self 'value)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'tensorflow.protobuf::attr-value))
      (cl:setf (cl:slot-value self 'value) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf value) :after (x (self name-attr-list-attr-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self name-attr-list-attr-entry))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self name-attr-list-attr-entry))
  (cl:setf (cl:slot-value self 'value) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)



(cl:defclass name-attr-list (pb:protocol-buffer)
  (
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (attr
   :accessor attr
   :initform (cl:make-array
              0
              :element-type 'tensorflow.protobuf::name-attr-list-attr-entry
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector tensorflow.protobuf::name-attr-list-attr-entry))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'name-attr-list)

(cl:export 'name)


(cl:defmethod (cl:setf name) :after (x (self name-attr-list))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self name-attr-list))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-name)

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self name-attr-list))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-name)

(cl:export 'attr)

(cl:unless (cl:fboundp 'clear-attr)
  (cl:defgeneric clear-attr (proto)))
(cl:defmethod clear-attr ((self name-attr-list))
  (cl:setf (cl:slot-value self 'attr)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::name-attr-list-attr-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-attr)


(cl:defmethod cl:print-object ((self name-attr-list-attr-entry) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self name-attr-list-attr-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self name-attr-list-attr-entry))
  cl:t)

(cl:defmethod pb:octet-size ((self name-attr-list-attr-entry))
  (cl:let ((size 0))
    ;; string key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; .tensorflow.protobuf.AttrValue value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'value))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self name-attr-list-attr-entry) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; .tensorflow.protobuf.AttrValue value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'value) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self name-attr-list-attr-entry) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string key = 1[json_name = "key"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .tensorflow.protobuf.AttrValue value = 2[json_name = "value"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'value)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
                (cl:setf (cl:slot-value self 'value) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self name-attr-list-attr-entry) (from name-attr-list-attr-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'value)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'tensorflow.protobuf::attr-value))
        (cl:setf (cl:slot-value self 'value) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'value))))
)



(cl:defmethod cl:print-object ((self name-attr-list) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:format stream " ~_attr: ~s" (attr self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self name-attr-list))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'attr)
           (cl:make-array 0 :element-type 'tensorflow.protobuf::name-attr-list-attr-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self name-attr-list))
  cl:t)

(cl:defmethod pb:octet-size ((self name-attr-list))
  (cl:let ((size 0))
    ;; string name = 1[json_name = "name"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; map<string, .tensorflow.protobuf.AttrValue> attr = 2[json_name = "attr"];
    (cl:let* ((v (cl:slot-value self 'attr))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self name-attr-list) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string name = 1[json_name = "name"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; map<string, .tensorflow.protobuf.AttrValue> attr = 2[json_name = "attr"];
  (cl:let* ((v (cl:slot-value self 'attr))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self name-attr-list) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string name = 1[json_name = "name"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; map<string, .tensorflow.protobuf.AttrValue> attr = 2[json_name = "attr"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'tensorflow.protobuf::name-attr-list-attr-entry)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'attr)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self name-attr-list) (from name-attr-list))
  (cl:let* ((v (cl:slot-value self 'attr))
            (vf (cl:slot-value from 'attr))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
)


