
;;;;    versions.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:tensorflow.protobuf)
    (make-package '#:tensorflow.protobuf :use nil)))
(in-package #:tensorflow.protobuf)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass version-def (pb:protocol-buffer)
  (
  (producer
   :accessor producer
   :initform 0
   :type (cl:signed-byte 32))
  (min-consumer
   :accessor min-consumer
   :initform 0
   :type (cl:signed-byte 32))
  (bad-consumers
   :accessor bad-consumers
   :initform (cl:make-array
              0
              :element-type '(cl:signed-byte 32)
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector (cl:signed-byte 32)))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'version-def)

(cl:export 'producer)


(cl:defmethod (cl:setf producer) :after (x (self version-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-producer)
  (cl:defgeneric has-producer (proto)))
(cl:defmethod has-producer ((self version-def))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-producer)

(cl:unless (cl:fboundp 'clear-producer)
  (cl:defgeneric clear-producer (proto)))
(cl:defmethod clear-producer ((self version-def))
  (cl:setf (cl:slot-value self 'producer) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-producer)

(cl:export 'min-consumer)


(cl:defmethod (cl:setf min-consumer) :after (x (self version-def))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-min-consumer)
  (cl:defgeneric has-min-consumer (proto)))
(cl:defmethod has-min-consumer ((self version-def))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-min-consumer)

(cl:unless (cl:fboundp 'clear-min-consumer)
  (cl:defgeneric clear-min-consumer (proto)))
(cl:defmethod clear-min-consumer ((self version-def))
  (cl:setf (cl:slot-value self 'min-consumer) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-min-consumer)

(cl:export 'bad-consumers)

(cl:unless (cl:fboundp 'clear-bad-consumers)
  (cl:defgeneric clear-bad-consumers (proto)))
(cl:defmethod clear-bad-consumers ((self version-def))
  (cl:setf (cl:slot-value self 'bad-consumers)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-bad-consumers)


(cl:defmethod cl:print-object ((self version-def) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_producer: ~s" (producer self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_min-consumer: ~s" (min-consumer self)))
      (cl:format stream " ~_bad-consumers: ~s" (bad-consumers self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self version-def))
  (cl:setf (cl:slot-value self 'producer) 0)
  (cl:setf (cl:slot-value self 'min-consumer) 0)
  (cl:setf (cl:slot-value self 'bad-consumers)
           (cl:make-array 0 :element-type '(cl:signed-byte 32)
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self version-def))
  cl:t)

(cl:defmethod pb:octet-size ((self version-def))
  (cl:let ((size 0))
    ;; int32 producer = 1[json_name = "producer"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'producer))))))
    ;; int32 min_consumer = 2[json_name = "minConsumer"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'min-consumer))))))
    ;; repeated int32 bad_consumers = 3[json_name = "badConsumers"];
    (cl:let* ((x (cl:slot-value self 'bad-consumers))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size
         (varint:length64 (cl:ldb (cl:byte 64 0) (cl:aref (cl:slot-value self 'bad-consumers) i))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self version-def) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int32 producer = 1[json_name = "producer"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'producer)))))
  ;; int32 min_consumer = 2[json_name = "minConsumer"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'min-consumer)))))
  ;; repeated int32 bad_consumers = 3[json_name = "badConsumers"];
  (cl:let* ((v (cl:slot-value self 'bad-consumers))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
      (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:aref v i))))))
  index)

(cl:defmethod pb:merge-from-array ((self version-def) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; int32 producer = 1[json_name = "producer"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'producer) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; int32 min_consumer = 2[json_name = "minConsumer"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'min-consumer) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated int32 bad_consumers = 3[json_name = "badConsumers"];
        ((26)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'bad-consumers))
              (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self version-def) (from version-def))
  (cl:let* ((v (cl:slot-value self 'bad-consumers))
            (vf (cl:slot-value from 'bad-consumers))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'producer) (cl:slot-value from 'producer))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'min-consumer) (cl:slot-value from 'min-consumer))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


